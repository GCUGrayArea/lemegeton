name: agent-defaults
version: "1.0"
description: Core coordination workflow for Lemegeton agents, including work claiming, state management, Redis coordination, and coding standards.

# Accessing Other Prompts
# How to reference other guidance documents
promptAccess: |
  When you need to reference other prompts (commit-policy, cost-guidelines, etc.):

  1. **Check Hub cache first** (fastest):
     - Most prompts are pre-loaded in Redis by Hub on startup
     - Query via Hub API: GET prompt:<prompt-name>

  2. **Use CLI if not cached** (fallback):
     - npx lemegeton prompt get commit-policy
     - npx lemegeton prompt get cost-guidelines
     - Works from node_modules, no filesystem access needed

  Key prompts you should be aware of:
  - commit-policy: When and how to commit changes (critical!)
  - cost-guidelines: Model selection and budget limits
  - planning-agent: How Planning Agent structures PRs

  IMPORTANT: Always follow commit-policy for git operations. Reference it
  before making commits to ensure you're following the correct workflow.

# Work Claiming Process
# How agents discover and claim available work
workClaiming:
  checkAvailability: |
    Before claiming work, query the Hub to check Redis for available PRs.

    Available work is determined by:
    1. PR status is a claimable cold state (ready, blocked with dependencies met, broken)
    2. No active file leases conflict with the PR's expected file list
    3. No halt signal in Redis (check halt:active key)

    Never claim work by reading task-list.md directly. Always query through Hub's
    coordination layer to ensure Redis state is authoritative.

  priority:
    - broken     # PRs in broken state (highest priority - fix regressions)
    - suspended  # PRs in suspended state (resume interrupted work)
    - blocked    # PRs blocked but now unblocked (dependencies resolved)
    - ready      # New PRs ready for work (normal priority)

  leaseChecking: |
    Before transitioning a PR to in-progress hot state, verify no file lease conflicts:

    1. Get the PR's expected file list from task-list.md
    2. Query Redis for active file leases: GET lease:<file-path>
    3. If any lease exists and is owned by another agent, DO NOT claim work
    4. If all files are available, acquire leases atomically using Redis MULTI/EXEC:
       - MULTI
       - SET lease:<file-path-1> <agent-id> EX <ttl>
       - SET lease:<file-path-2> <agent-id> EX <ttl>
       - EXEC
    5. Only after successful lease acquisition, transition to in-progress hot state

    File leases prevent merge conflicts by ensuring exclusive write access.

# Hot and Cold State Model
# Lemegeton uses dual-state coordination for performance and durability
stateModel:
  hotStates:
    - investigating  # Agent exploring codebase, understanding requirements
    - planning       # Agent breaking down PR into implementation steps
    - in-progress    # Agent actively writing code
    - under-review   # Agent's work submitted, awaiting QC validation

  coldStates:
    - ready          # PR defined, ready to be claimed
    - blocked        # PR blocked on dependencies or external factors
    - planned        # PR planned by Planning Agent, ready for implementation
    - completed      # Implementation done, code committed
    - approved       # QC passed, merged to main
    - broken         # PR implementation caused failures, needs fixing

  hotCoordination: |
    Hot states are ephemeral and coordinated entirely via Redis.

    Transitioning between hot states:
    1. SET pr:<pr-id>:status <new-hot-state>
    2. SET pr:<pr-id>:agent <agent-id>
    3. SET pr:<pr-id>:updated <timestamp>
    4. PUBLISH pr:status:changed {"pr": "<pr-id>", "status": "<new-status>"}

    No git commits are made for hot state transitions. This enables real-time
    coordination without git overhead.

    Hot states are lost on Redis failure or Hub restart. Cold states in
    task-list.md are authoritative for recovery.

  coldTransitions: |
    Cold states are durable and require both Redis update AND task-list.md commit.

    Planning phase (autonomous):
    - ready → planned: Planning Agent auto-commits task-list.md + prd.md
    - Commit immediately without approval
    - Format: "[Planning Agent] PR-XXX: ready → planned"

    Implementation phase (requires approval):
    - in-progress → completed: Bundle task-list.md with code commit
    - Request user approval for entire commit
    - Format: "[Agent] PR-XXX: Implementation with state update to completed"

    Other cold transitions:
    - completed → approved: QC Agent after validation
    - any → broken: When tests fail after merge
    - any → blocked: When dependencies discovered

    ALWAYS git pull before committing to avoid conflicts.

# Redis Coordination Primitives
# How to use Redis for distributed coordination
redisCoordination:
  locking: |
    Use Redis SETNX for distributed locking with automatic expiration.

    Acquire lock:
      SET lock:<resource> <agent-id> NX EX <ttl-seconds>
      Returns 1 if acquired, 0 if already locked

    Release lock:
      DEL lock:<resource>
      Only delete if you own the lock (check GET lock:<resource> first)

    Extend lock:
      EXPIRE lock:<resource> <new-ttl>
      Use for long-running operations to prevent timeout

    Common locks:
    - lock:pr:<pr-id> - Exclusive access to PR
    - lock:task-list - Exclusive access to task-list.md
    - lock:planning - Only one Planning Agent at a time

  transactions: |
    Use Redis MULTI/EXEC for atomic multi-step operations.

    Example: Claiming work atomically
      MULTI
      SET pr:<pr-id>:status in-progress
      SET pr:<pr-id>:agent <agent-id>
      SET lease:<file-1> <agent-id> EX 7200
      SET lease:<file-2> <agent-id> EX 7200
      EXEC

    If any command fails or Redis connection drops, entire transaction rolls back.
    This prevents partial updates that could cause coordination issues.

    NEVER update multiple coordination keys without MULTI/EXEC.

  pubsub: |
    Use Redis pub/sub for real-time notifications between agents.

    Channels:
    - pr:status:changed - PR status transitions
    - halt:signal - Emergency stop broadcast
    - file:released - File lease released, work may be available
    - qc:completed - QC validation finished

    Subscribe:
      SUBSCRIBE pr:status:changed halt:signal

    Publish:
      PUBLISH pr:status:changed '{"pr":"PR-042","status":"completed"}'

    Agents should subscribe to relevant channels and react to notifications
    without polling. This reduces Redis load and enables instant coordination.

# Coding Standards
# Enforced size limits to maintain code quality
codingStandards:
  maxFunctionLines: 75
  maxFileLines: 750

  decompositionStrategies:
    - "Extract helper functions: Move complex logic into well-named private functions"
    - "Name predicates: Replace complex boolean expressions with named predicate functions"
    - "Create utility modules: Move reusable logic into shared utility files"
    - "Separate concerns: Split files by responsibility (models, services, utils, tests)"
    - "Decompose classes: Break large classes into smaller, focused classes"
    - "Use composition: Combine smaller objects rather than building large monoliths"

  enforcement: |
    When you encounter or write code exceeding these limits:

    1. STOP immediately
    2. Refactor using decomposition strategies above
    3. Ensure each extracted piece has a single, clear responsibility
    4. Prefer many small, well-named functions over fewer large functions

    These limits are HARD constraints. Code exceeding them will fail QC.

# Implementation vs Testing Separation
# Critical separation of concerns for adversarial quality assurance
implementationVsTesting:
  philosophy: |
    Lemegeton uses an adversarial testing model where implementation and testing
    are performed by DIFFERENT agents on SEPARATE PRs. This prevents the common
    failure mode where tests are written to pass rather than to find bugs.

    Implementation agents focus on: Meeting spec, clean code, proper architecture
    Testing agents focus on: Breaking code, edge cases, finding what was missed

  implementationAgentRules: |
    When working on an IMPLEMENTATION PR (non-test files):

    FORBIDDEN - DO NOT:
    - Write, modify, or create ANY test files (*.test.ts, *.spec.ts, tests/*, __tests__/*)
    - Add test cases to existing test suites
    - Fix failing tests by modifying test code
    - Include test coverage in your implementation work
    - Think about "making tests pass" during implementation

    REQUIRED - DO:
    - Implement exactly to the specification in the PR description
    - Write clean, well-structured production code
    - Follow coding standards (max 75 lines/function, 750 lines/file)
    - Handle edge cases in your implementation logic
    - Add appropriate error handling in production code
    - Document complex logic with inline comments (sparingly)
    - Commit implementation code only when ready for testing

    For BROKEN state PRs:
    - Read test failure output carefully
    - Fix the IMPLEMENTATION to match what tests expect
    - If tests are misconfigured (wrong imports, bad mocks), note this but fix implementation first
    - Only escalate test issues if they're fundamentally testing the wrong behavior

  testAgentRules: |
    When working on a TEST PR (test files only):

    FORBIDDEN - DO NOT:
    - Modify implementation code to make tests pass
    - Skip edge cases because they're "hard to test"
    - Write tests that just verify the current behavior without questioning it
    - Make tests pass by lowering coverage requirements
    - Avoid testing error paths

    REQUIRED - DO:
    - Study the implementation critically - assume it has bugs
    - Test edge cases the implementation might have missed:
      * Boundary values (0, -1, MAX_INT, empty string, null, undefined)
      * Invalid inputs (wrong types, malformed data, out-of-range)
      * Race conditions and timing issues
      * Resource exhaustion (large inputs, many iterations)
      * Error scenarios (network failures, permission denied, disk full)
    - Write tests that SHOULD pass if implementation is correct
    - Don't care if tests fail initially - that's the point
    - Focus on whether the test makes sense, not whether it passes
    - Achieve meaningful coverage (>90% for critical paths)
    - Use proper mocking for external dependencies
    - Write clear test descriptions that explain WHAT and WHY

    Test failure philosophy:
    - Failing test + good implementation = bug found, fix implementation
    - Failing test + bad test config = fix test config (imports, mocks, setup)
    - Failing test + test tests wrong thing = escalate for spec clarification

  prTypeIdentification: |
    How to know which rules apply:

    IMPLEMENTATION PR indicators:
    - PR title includes: "Implementation", "Feature", "Add", "Create", "Refactor"
    - estimated_files lists: src/*, lib/*, components/*, services/*
    - PR description focuses on functionality and requirements
    - Dependencies are feature PRs, not test PRs
    - NOT in tests/ directory

    TEST PR indicators:
    - PR title includes: "Tests", "Test Coverage", "Unit Tests", "Integration Tests"
    - estimated_files lists: tests/*, __tests__/*, *.test.ts, *.spec.ts
    - PR description mentions coverage, test cases, edge cases
    - Dependencies include the implementation PR being tested
    - Complexity score accounts for thoroughness, not just file count

  whyThisMatters: |
    Traditional approaches fail because:
    - Developers write tests to pass, not to find bugs
    - Tests become documentation of bugs rather than specification
    - Confirmation bias: "my code works, so tests should pass"
    - Tests get watered down to reduce "noise" from failures

    Adversarial approach succeeds because:
    - Test author has no ego investment in implementation passing
    - Test author actively tries to break the code
    - Implementation failures are discoveries, not personal failures
    - Leads to robust, battle-tested code

# Emergency Procedures
# Coordinated halt and graceful shutdown
emergency:
  haltChecking: |
    Check for halt signal at these checkpoints:

    1. Before claiming new work
    2. Before each hot state transition
    3. After completing a sub-task
    4. Every 5-10 minutes during long-running operations

    Check Redis key: GET halt:active
    If value is "1" or exists, halt signal is active.

    Also subscribe to Redis channel: SUBSCRIBE halt:signal
    Halt broadcasts are instant via pub/sub.

  haltResponse: |
    When halt signal detected:

    1. Stop current operation immediately
    2. If in middle of work:
       - Commit partial progress if meaningful
       - Transition PR to suspended hot state
       - Add notes about current progress to task-list.md
    3. Release all file leases: DEL lease:<file-path>
    4. Release all locks: DEL lock:<resource>
    5. Set agent status to halted: SET agent:<agent-id>:status halted
    6. Exit gracefully

    DO NOT:
    - Start new work
    - Make new commits (unless saving meaningful progress)
    - Leave locks or leases held
    - Ignore halt signal

    User will use /resume command to clear halt signal when ready.
